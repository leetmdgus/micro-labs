<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HWPX Slot Filler</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
    .wrap { max-width: 980px; margin: 0 auto; }
    h1 { font-size: 20px; margin: 0 0 12px; }
    p { color: #444; margin: 0 0 20px; line-height: 1.6; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 12px; }
    label { display:block; font-size: 12px; color:#666; margin-bottom: 6px; }
    select, input, textarea {
      width: 100%; box-sizing: border-box; border: 1px solid #ccc; border-radius: 8px;
      padding: 10px; font-size: 14px;
    }
    input[type="file"] { padding: 8px; }
    textarea { min-height: 88px; resize: vertical; }
    .row { display:flex; gap: 10px; align-items:center; margin-top: 14px; flex-wrap: wrap; }
    button {
      border: 0; border-radius: 10px; padding: 10px 14px; font-size: 14px;
      cursor: pointer; background: #111; color: #fff;
    }
    button:disabled { opacity: 0.5; cursor: default; }
    .hint { color:#666; font-size:12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .small { font-size: 12px; color: #666; }
    .preview { margin-top: 8px; font-size: 12px; color: #666; }
    .topbar { display:flex; gap:12px; align-items:flex-end; flex-wrap: wrap; margin-bottom: 12px; }
    .topbar .card { flex: 1; min-width: 280px; }
    @media (max-width: 760px) { .grid { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
<div class="wrap">
  <h1>HWPX 템플릿 선택 및 슬롯 입력</h1>
  <p>
    템플릿을 선택하면 해당 템플릿의 slot_map.json을 로드합니다.
    이미지 슬롯(<span class="mono">IMG_</span>로 시작)은 파일 업로드로 처리됩니다.
    <span class="small">(STRIP_CLICK_HERE=false)</span>
  </p>

  <div class="topbar">
    <div class="card">
      <label>템플릿 선택</label>
      <select id="tplSelect"></select>
      <div class="row" style="margin-top:10px;">
        <button id="btnDownloadTpl" disabled>원본 템플릿 다운로드</button>
        <button id="btnOpenSlotMap" disabled>slot_map.json 열기</button>
        <span id="tplHint" class="hint"></span>
      </div>
      <div class="small" style="margin-top:8px;">
        slot_map 파일: <span id="slotMapPath" class="mono"></span>
      </div>
    </div>
  </div>

  <div id="slots" class="grid"></div>

  <div class="row">
    <button id="btnGenerate" disabled>final.hwpx 생성</button>
    <span id="status" class="hint"></span>
  </div>

  <div class="row">
    <span class="hint">슬롯 개수: <span id="count" class="mono"></span></span>
    <span class="small">텍스트 빈 값은 전송하지 않습니다. 이미지 슬롯은 파일 선택 시만 전송합니다.</span>
  </div>
</div>

<script>
  const slotsEl = document.getElementById('slots');
  const btnGenerate = document.getElementById('btnGenerate');
  const statusEl = document.getElementById('status');
  const countEl = document.getElementById('count');
  const tplSelect = document.getElementById('tplSelect');
  const btnDownloadTpl = document.getElementById('btnDownloadTpl');
  const btnOpenSlotMap = document.getElementById('btnOpenSlotMap');
  const tplHint = document.getElementById('tplHint');
  const slotMapPathEl = document.getElementById('slotMapPath');

  let currentTemplateId = null;
  const imageState = {};

  function resetImages() {
    for (const k of Object.keys(imageState)) delete imageState[k];
  }

  function makeTextField(slotName, meta) {
    const card = document.createElement('div');
    card.className = 'card';

    const label = document.createElement('label');
    const loc = meta && meta[0]
      ? ` (${meta[0].xml_path}, row=${meta[0].row_addr}, col=${meta[0].col_addr})`
      : '';
    label.textContent = slotName + loc;

    const input = document.createElement('textarea');
    input.placeholder = slotName + ' 값 입력';
    input.dataset.slot = slotName;

    card.appendChild(label);
    card.appendChild(input);
    return card;
  }

  function makeImageField(slotName, meta) {
    const card = document.createElement('div');
    card.className = 'card';

    const label = document.createElement('label');
    const loc = meta && meta[0]
      ? ` (${meta[0].xml_path}, row=${meta[0].row_addr}, col=${meta[0].col_addr})`
      : '';
    label.textContent = slotName + loc + " (이미지 업로드)";

    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.dataset.imgslot = slotName;

    const preview = document.createElement('div');
    preview.className = 'preview';
    preview.textContent = '선택된 파일 없음';

    input.onchange = async () => {
      const f = input.files && input.files[0];
      if (!f) {
        delete imageState[slotName];
        preview.textContent = '선택된 파일 없음';
        return;
      }
      const dataUrl = await new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => resolve(r.result);
        r.onerror = () => reject(new Error('file read error'));
        r.readAsDataURL(f);
      });
      imageState[slotName] = { filename: f.name, dataUrl: dataUrl };
      preview.textContent = `선택됨: ${f.name} (${Math.round(f.size/1024)}KB)`;
    };

    card.appendChild(label);
    card.appendChild(input);
    card.appendChild(preview);
    return card;
  }

  async function fetchTemplates() {
    const res = await fetch('/templates');
    if (!res.ok) throw new Error('templates fetch failed');
    return await res.json();
  }

  async function loadSlotMap(templateId) {
    const res = await fetch('/slot_map.json?template=' + encodeURIComponent(templateId));
    if (!res.ok) {
      const t = await res.text();
      throw new Error(t || 'slot_map fetch failed');
    }
    return await res.json();
  }

  function renderSlots(slotMap) {
    resetImages();
    slotsEl.innerHTML = '';

    const slotNames = Object.keys(slotMap).sort();
    countEl.textContent = String(slotNames.length);

    slotNames.forEach(name => {
      if (name.startsWith('IMG_')) {
        slotsEl.appendChild(makeImageField(name, slotMap[name]));
      } else {
        slotsEl.appendChild(makeTextField(name, slotMap[name]));
      }
    });

    btnGenerate.disabled = slotNames.length === 0 || !currentTemplateId;
  }

  function updateSlotMapPath(templateId) {
    slotMapPathEl.textContent = 'generated_slot_maps/' + templateId + '.slot_map.json';
  }

  async function init() {
    statusEl.textContent = '템플릿 로딩 중...';
    const templates = await fetchTemplates();

    tplSelect.innerHTML = '';
    templates.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t.id;
      opt.textContent = t.id;
      tplSelect.appendChild(opt);
    });

    if (templates.length === 0) {
      statusEl.textContent = 'templates 폴더에 .hwpx 템플릿을 넣어주세요.';
      btnGenerate.disabled = true;
      btnDownloadTpl.disabled = true;
      btnOpenSlotMap.disabled = true;
      tplHint.textContent = '';
      slotMapPathEl.textContent = '';
      return;
    }

    currentTemplateId = templates[0].id;
    tplSelect.value = currentTemplateId;

    btnDownloadTpl.disabled = false;
    btnOpenSlotMap.disabled = false;
    tplHint.textContent = '선택됨: ' + currentTemplateId;
    updateSlotMapPath(currentTemplateId);

    const slotMap = await loadSlotMap(currentTemplateId);
    renderSlots(slotMap);

    statusEl.textContent = '';

    tplSelect.onchange = async () => {
      try {
        currentTemplateId = tplSelect.value;
        tplHint.textContent = '선택됨: ' + currentTemplateId;
        updateSlotMapPath(currentTemplateId);
        statusEl.textContent = '슬롯 로딩 중...';
        btnGenerate.disabled = true;

        const slotMap2 = await loadSlotMap(currentTemplateId);
        renderSlots(slotMap2);

        statusEl.textContent = '';
      } catch (e) {
        statusEl.textContent = '템플릿 변경 오류: ' + (e && e.message ? e.message : String(e));
      }
    };

    btnDownloadTpl.onclick = () => {
      if (!currentTemplateId) return;
      const a = document.createElement('a');
      a.href = '/download_template?template=' + encodeURIComponent(currentTemplateId);
      a.download = currentTemplateId + '.hwpx';
      document.body.appendChild(a);
      a.click();
      a.remove();
    };

    btnOpenSlotMap.onclick = () => {
      if (!currentTemplateId) return;
      window.open('/slot_map.json?template=' + encodeURIComponent(currentTemplateId), '_blank');
    };

    btnGenerate.onclick = async () => {
      try {
        btnGenerate.disabled = true;
        statusEl.textContent = '생성 중...';

        const payload = { template: currentTemplateId, values: {} };

        document.querySelectorAll('[data-slot]').forEach(el => {
          const v = (el.value || '').trim();
          if (v.length > 0) payload.values[el.dataset.slot] = v;
        });

        Object.keys(imageState).forEach(k => {
          payload.values[k] = imageState[k];
        });

        const r = await fetch('/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });

        if (!r.ok) {
          const t = await r.text();
          throw new Error(t || 'server error');
        }

        const blob = await r.blob();
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'final.hwpx';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);

        statusEl.textContent = '완료: final.hwpx 다운로드됨';
      } catch (e) {
        statusEl.textContent = '오류: ' + (e && e.message ? e.message : String(e));
      } finally {
        btnGenerate.disabled = false;
      }
    };
  }

  init().catch(e => {
    statusEl.textContent = '초기화 오류: ' + e.message;
  });
</script>
</body>
</html>
