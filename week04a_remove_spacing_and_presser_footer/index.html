<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HWPX Slot Filler</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
    .wrap { max-width: 980px; margin: 0 auto; }
    h1 { font-size: 20px; margin: 0 0 12px; }
    p { color: #444; margin: 0 0 20px; line-height: 1.6; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 12px; }
    label { display:block; font-size: 12px; color:#666; margin-bottom: 6px; }
    input, textarea {
      width: 100%; box-sizing: border-box; border: 1px solid #ccc; border-radius: 8px;
      padding: 10px; font-size: 14px;
    }
    input[type="file"] { padding: 8px; }
    textarea { min-height: 88px; resize: vertical; }
    .row { display:flex; gap: 10px; align-items:center; margin-top: 14px; flex-wrap: wrap; }
    button {
      border: 0; border-radius: 10px; padding: 10px 14px; font-size: 14px;
      cursor: pointer; background: #111; color: #fff;
    }
    button:disabled { opacity: 0.5; cursor: default; }
    .hint { color:#666; font-size:12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .small { font-size: 12px; color: #666; }
    .preview { margin-top: 8px; font-size: 12px; color: #666; }
    @media (max-width: 760px) { .grid { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
<div class="wrap">
  <h1>HWPX 슬롯 입력</h1>
  <p>
    텍스트 슬롯은 값이 주입되고, 이미지 슬롯(<span class="mono">IMG_</span>로 시작)은 파일 업로드로 처리됩니다.
    <span class="small">(STRIP_CLICK_HERE=false)</span>
  </p>

  <div id="slots" class="grid"></div>

  <div class="row">
    <button id="btn" disabled>final.hwpx 생성</button>
    <span id="status" class="hint"></span>
  </div>

  <div class="row">
    <span class="hint">슬롯 개수: <span id="count" class="mono"></span></span>
    <span class="small">텍스트는 입력 그대로(공백/줄바꿈 포함) 전송합니다. 이미지 슬롯은 파일 선택 시만 전송합니다.</span>
  </div>
</div>

<script>
  const slotsEl = document.getElementById('slots');
  const btn = document.getElementById('btn');
  const statusEl = document.getElementById('status');
  const countEl = document.getElementById('count');

  const imageState = {};

  function makeTextField(slotName, meta) {
    const card = document.createElement('div');
    card.className = 'card';

    const label = document.createElement('label');
    const loc = meta?.[0]
      ? ` ({${meta[0].xml_path}}, row={${meta[0].row_addr}}, col={${meta[0].col_addr}})`
      : '';
    label.textContent = slotName + loc;

    const input = document.createElement('textarea');
    input.placeholder = slotName + ' 값 입력';
    input.dataset.slot = slotName;

    card.appendChild(label);
    card.appendChild(input);
    return card;
  }

  function makeImageField(slotName, meta) {
    const card = document.createElement('div');
    card.className = 'card';

    const label = document.createElement('label');
    const loc = meta?.[0]
      ? ` ({${meta[0].xml_path}}, row={${meta[0].row_addr}}, col={${meta[0].col_addr}})`
      : '';
    label.textContent = slotName + loc + " (이미지 업로드)";

    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.dataset.imgslot = slotName;

    const preview = document.createElement('div');
    preview.className = 'preview';
    preview.textContent = '선택된 파일 없음';

    input.onchange = async () => {
      const f = input.files && input.files[0];
      if (!f) {
        delete imageState[slotName];
        preview.textContent = '선택된 파일 없음';
        return;
      }
      const dataUrl = await new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => resolve(r.result);
        r.onerror = () => reject(new Error('file read error'));
        r.readAsDataURL(f);
      });
      imageState[slotName] = { filename: f.name, dataUrl };
      preview.textContent = `선택됨: ${f.name} (${Math.round(f.size/1024)}KB)`;
    };

    card.appendChild(label);
    card.appendChild(input);
    card.appendChild(preview);
    return card;
  }

  async function init() {
    const res = await fetch('/slot_map.json');
    if (!res.ok) throw new Error('slot_map.json fetch failed');

    const slotMap = await res.json();
    const slotNames = Object.keys(slotMap).sort();

    countEl.textContent = String(slotNames.length);
    slotsEl.innerHTML = '';

    slotNames.forEach(name => {
      if (name.startsWith('IMG_')) {
        slotsEl.appendChild(makeImageField(name, slotMap[name]));
      } else {
        slotsEl.appendChild(makeTextField(name, slotMap[name]));
      }
    });

    btn.disabled = slotNames.length === 0;

    btn.onclick = async () => {
      try {
        btn.disabled = true;
        statusEl.textContent = '생성 중...';

        const payload = {};

        // trim 제거: 공백/줄바꿈 그대로 보냄
        document.querySelectorAll('[data-slot]').forEach(el => {
          const v = (el.value ?? '');
          if (v.length > 0) payload[el.dataset.slot] = v;
        });

        Object.keys(imageState).forEach(k => {
          payload[k] = imageState[k];
        });

        const r = await fetch('/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });

        if (!r.ok) {
          const t = await r.text();
          throw new Error(t || 'server error');
        }

        const blob = await r.blob();
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'final.hwpx';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);

        statusEl.textContent = '완료: final.hwpx 다운로드됨';
      } catch (e) {
        statusEl.textContent = '오류: ' + (e?.message || String(e));
      } finally {
        btn.disabled = false;
      }
    };
  }

  init().catch(e => {
    statusEl.textContent = '초기화 오류: ' + e.message;
  });
</script>
</body>
</html>
